current todo:
	- Update current task at end of dispatch if there is no current one
		- refactor the implementation, take out the "check how many of each task there are" logic, add optimized db count operations for each category
	- map_err on create table calls in db::SqliteBackend::create_tables
	- implement Task::format_long
		- format long for output of current task etc, anywhere we output "the current task is now: {format_long}"
	- implement frontend for current
		- display current task in list with asterisk or something
		- determine whether to select current in add or current or whatever
			- i think it's probably simpler if we only choose the current task when the current command is run
			- it does mean that if we run list then there might not be a current task selected

implement database operations:
	- decide which operation to implement next
		- Break: set break probability
		- Complete: mark task as complete
		- Skip: skip current task
	- write test for that operation
	- implement operation
	- refactor, iterate


once we implement format_long, maybe use terminal codes to bold the task description or something

deduplicate task validation code in Add struct and Task::from_parts

add ordering id to task in db:
	- for selecting/mapping output lists to db items, use an explicit ordering column that preserves the invariant UNIQUE and also that there are no gaps. on delete, shift everything up, and by default it appends. in a mobile/web app you would also be able to reorder i guess. what if you want to list by priority? do you change the ordering? no. but maybe you want the ordering column to insert such that instead of appending, you insert after the smallest task with a greater than or equal priority, so that the ordering id always matches the priority sorted id. you could also achieve this by sorting after every update if the sort is stable (wrt the task string etc.)

specify output ordering explicitly:
	- right now it is specified in the code by virtue of the sqlite query order by clause
	- this makes tests somewhat fragile

improve row output in list by counting number of digits and using that to choose column width instead of using a hardcoded size
	- literally could just write a function "if x < 10 return 1, else if x < 100 return 2, if x < 10000 return 3 [...] up to max u32"
	- actually just do l = [(10, 1), (100, 2), (1000,3),...] find first where x < l[i][0], return l[i][1]
also improve row output by adding a cutoff length for task and putting ... at the end
	- problems with this: "length" is in terms of columns, and while there is a "char::width" it is unstable. could just assume char::width==1 for now and count chars
	- there's probably a crate that does this for me

test and implement config parsing:
	- pick config dir and file
	- Default::default impl if failure to read or file does not exist
	- maybe add command line options at some point to select directory
	- deserialize config

related: improve command line argument testing:
	- use assert_cmd/assert_cli to test clap/structopt validators
		- esp. add validators, currently it is being tested via an additional panic inside the add
		- panics can be removed if we have the ability to err on task creation
		- then we can just go back to original strategy of checking that TKZCmd::dispatch/Add::run returns the correct err
		- still somewhat unsatisfying since we're testing the same behavior in multiple places (in the command line parser, the dispatch/run function, and the task constructor)

improve error messages:
	- make custom fail types
	- backtraces?
		- so the thing here is that at the db level, inside add_task, I might do something like `format_err!("Could not insert into db: {}", e)` where e is an external error
		- but then at a higher level i.e. the command level I might `format_err!("Could not add task: {}", e)`
		- So what i really want is a backtrace. so the todo here is to determine whether this is what failure provides
		- I want to be able to compose errors such that each level provides more details about what went wrong, so that when it bubbles up to the top layer I can display the top-level error message along with more details about what actually went wrong.
		- Ideally you could almost write a paragraph. "Could not add task. Could not insert into database. Could not insert row into database. <SQLite error>". This is kind of what I get now by doing `.map_err(format_err!("[...]. {}", prev_err))`

write more tests for failure conditions:
	- corrupt db?
	- bad permissions on config directory once config is implemented
