current todo:
	- implement frontend for current
		- display current task in list with asterisk or something
		- determine whether to select current in add or current or whatever
			- i think it's probably simpler if we only choose the current task when the current command is run
			- it does mean that if we run list then there might not be a current task selected

implement database operations:
	- decide which operation to implement next
		- Break: set break probability
		- Complete: mark task as complete
		- Skip: skip current task
	- write test for that operation
	- implement operation
	- refactor, iterate

add ordering id to task in db:
	- for selecting/mapping output lists to db items, use an explicit ordering column that preserves the invariant UNIQUE and also that there are no gaps. on delete, shift everything up, and by default it appends. in a mobile/web app you would also be able to reorder i guess. what if you want to list by priority? do you change the ordering? no. but maybe you want the ordering column to insert such that instead of appending, you insert after the smallest task with a greater than or equal priority, so that the ordering id always matches the priority sorted id. you could also achieve this by sorting after every update if the sort is stable (wrt the task string etc.)

specify output ordering explicitly:
	- right now it is specified in the code by virtue of the sqlite query order by clause
	- this makes tests somewhat fragile

improve display in list command:
	- align columns
		- format should be able to do this?
		- probably cut off for overflow because we will still show the whole task in `current` command anyway
related: implement Task::format_row and Task::format_long
	- format row for list view
	- format long for output of current task etc, anywhere we output "the current task is now: {format_long}"

test and implement config parsing:
	- pick config dir and file
	- Default::default impl if failure to read or file does not exist
	- maybe add command line options at some point to select directory
	- deserialize config

implement Task::from_parts and maybe make fields private and add getters

related: improve command line argument testing:
	- use assert_cmd/assert_cli to test clap/structopt validators
		- esp. add validators, currently it is being tested via an additional panic inside the add
		- panics can be removed if we have the ability to err on task creation
		- then we can just go back to original strategy of checking that TKZCmd::dispatch/Add::run returns the correct err
		- still somewhat unsatisfying since we're testing the same behavior in multiple places (in the command line parser, the dispatch/run function, and the task constructor)

improve error messages:
	- make custom fail types
	- backtraces?
		- so the thing here is that at the db level, inside add_task, I might do something like `format_err!("Could not insert into db: {}", e)` where e is an external error
		- but then at a higher level i.e. the command level I might `format_err!("Could not add task: {}", e)`
		- So what i really want is a backtrace. so the todo here is to determine whether this is what failure provides
		- I want to be able to compose errors such that each level provides more details about what went wrong, so that when it bubbles up to the top layer I can display the top-level error message along with more details about what actually went wrong.
		- Ideally you could almost write a paragraph. "Could not add task. Could not insert into database. Could not insert row into database. <SQLite error>". This is kind of what I get now by doing `.map_err(format_err!("[...]. {}", prev_err))`

write more tests for failure conditions:
	- corrupt db?
	- bad permissions on config directory once config is implemented
