add task:
	parameters:
		- type
			- task or reward, maybe for prototype just have a flag that marks it as a reward but in general you could have multiple different types of tasks with different probabilities to choose. for now choosing a reward with a hardcoded percentage 
		- name
		- priority
			- lowest 1 highest infty (well, max usize i guess)
	
list tasks:
	- prints a list of tasks
		- I guess just two lists, one of tasks and one of rewards

show current task:
	- print current active task

complete task:
	- removes current task from task list
		- if task is reward keep by default?
	- maybe keep a log of completed tasks by day or something?

	parameters:
		- maybe have a --keep parameter
		- maybe use it like `tkz complete [--keep] "notes about completed task"` i.e. anything at the end is treated as a string containing notes about the task, like a git commit message

skip task:
	- returns current task to task list

	parameters:
		- maybe optional note why it was skipped
		- maybe a message if the task gets skipped a lot

---

more features:
recurring tasks like todoist
arbitrary categories
randomized timer with notification

--- 

no select task - if you finish that specific task while it isn't current, just skip it when it gets randomly selected
	- eventually i guess if there are a bunch of low priority tasks it can get cluttered so maybe delete would be useful
	- list indices on list command, use those to delete

---

I changed the terminology from reward to break because it sounds nicer but left reward as the actual variable in the code since break is a keyword

---
testing ideas:

define a trait for above database operations, then either put boxed or impl trait when used in structs/params for testing with mocks

for choosing random task, it should be easier, just put the actual randomly generated value as a parameter

---

sync ideas:

eventually if i make a web ver. and do sync, how do you do it?

"unsynced operations" table? in the case we are offline or manually sync, otherwise just do it immediately if we have connection.

fancy CDRT stuff?

add a task:
	- can always merge adds
	- if server doesn't receive acknowledgement but updates were delivered we can get duplicated adds?
		- if we check guids that isn't a problem
delete a task:
	- need to use ID, so would need to add global ids to tasks
	- if task was created and then completed while offline, or before the other party had to sync, then i guess we don't even need to send that in the first place but also it's not an error
		- if we put it in an unsynced operations table we can check if the corresponding add is also unsynced
		- probably unnecessary

---

more sync ideas:

saw in an HN comment, add an operation ID to prevent duplicate operations. if you see the operation id twice then you know the client didn't see an ack.

---

database:
ideally, all database operations should be self-contained so that you never need to handle db indices outside the actual db operation code

	!!! need to do "pragma foreign_keys = ON;" !!!

	tasks table:
		id, task, priority, category

		"create table tasks (
			id INTEGER PRIMARY KEY,
			task TEXT NOT NULL,
			priority INTEGER NOT NULL,
			category INTEGER NOT NULL
		);"

	current task table:
		foreignkey to tasks table id?
		should always have exactly 0 or 1 elements

		"create table current (
			id INTEGER PRIMARY KEY check (id = 1),
			task_id INTEGER NOT NULL,
			foreign key (task_id) references tasks(id),
		);"

	completed tasks table:
		id, task, category, date completed

		"create table completed (
			id INTEGER PRIMARY KEY,
			task TEXT NOT NULL,
			category INTEGER NOT NULL,
			date_completed TEXT NOT NULL
		);"
	
	metadata table:
		version number, creation date
		check if version number is equal to cargo version number

		"create table metadata {
			id INTEGER PRIMARY KEY check (id = 1),
			version TEXT NOT NULL,
			date_created TEXT NOT NULL
		);"

	- current task table probably saves space compared to having an extra "current" bool column and makes it easier to preserve the "only one current active task" invariant
	- completed task table also saves space and probably helps prevent bugs accidentally selecting completed tasks when selecting current from tasks table

creation operations:
- open
	probably just open or create

	for create:
		- sqlite: foreign key pragma
		- create tables

operations for each action:
- add
	- insert to database
- list
	I guess for now I can just return a tuple of vecs or something
	- get all tasks, sorted by category and then priority
	- maybe query each separately?
		- i.e.
		"select [...] from tasks where category=task order by priority"
		"select [...] from tasks where category=reward order by priority"
		
		- probably not necessary, just append to different vecs inside query_map
- show current
	- can do in one query:
	"select [...] from tasks where id =
		( select taskid from current where id = 1 )
	- if 0 results no current task set, but i don't think it's an error

- complete task
	- get current task
	- add current task to completed
	- remove current task from tasks table
		- same query as show current but delete instead of select
		- we need to return the task as well though, so get select first
	- get all tasks as in list operation
	- (not db operation) choose new task
	- set current task: "replace into current (id, task_id) values (1, :task_id);"

- skip task
	- same as complete task but without removal operation

so, operations needed:

tasks_add(Task) -> Result<(), Error>
tasks_list() -> Result<(Vec<Task>, Vec<Task>), Error>
tasks_current() -> Result<Task, Error>
tasks_remove_current() -> Result<Task, Error>
current_set(Task)
completed_add(Task) -> Result<(), Error> 
tasks_skip

---

drop impl on database struct to close?

---

I got caught up in trying to figure out the best way to do categories and not expose primary keys/ids to the user api (do you make a guid for the category, or do you just call the category string/text a "natural key" and put a UNIQUE on the name column and do queries on the text, etc) so since this is a "prototype" i'm just going to make it a bool.

I think the right way is probably to have a table that's |rowid|category|category_priority| and have a foreign key in the task table pointing to the category

then when you populate a task struct you join on the category_id and put in an actual category struct
similarly when you insert a task it only has the category name, and I guess the insert should fail if the category doesn't exist because of the foreign key check

--- 

property testing idea, I could make an arb_db() that just calls the create test db utility function, and then compose with other ops to get like "arb_db_with_tasks()" maybe

---

we can view the main function in a cli to essentially be a render function which renders by printing.

we could i guess make it more complicated and have render functions for each of the commands or something?

cli control flow is input (structopt) -> command (dispatch, business logic) -> output (display result of dispatch)

so really we could have different renders for each of the outputs of the commands

but really they're all going to output the same type (a list of strings to print out, a widget tree, whatever ncurses does, or whatever)

--

could make taskerizer per-project by putting it in a dotfile in the current directory.

interface would maybe be like `tkzr create [dir]` dir optional with default value current directory

and then all commands would first look up the tree for a .tkzr/ before looking in the default 'global' directory

alternatively use new vim model of putting per-directory files inside global dir. probably better option to do this.

add override command -g --global to tkzr, or maybe option in config

website/mobile implementation i guess would be "projects" and then the tkzr command would be `tkzr create <name> [dir]`, or maybe it just uses the name of the directory.
	this is something where i could see it as being a paid feature, much like todoist

---

Going to try to make the tests use an in-memory db because it's slow on a test machine I use. i originally didn't want to do this because then you have the same problem as using a mock: you have to test the part that you're mocking separately. so I think probably what i'll end up doing is use the in-memory db for unit tests and writing to disk for integration tests (i.e. the tests in the tests/ directory)

in order to do this I think i have to refactor the connection opening code or maybe more generally the config-based code to outside the commands. so i would acquire the db connection, and then dispatch the commands, only passing the connection and other data into the run function for each command. for the unit tests for the db I think I just need to change the call used in `src/db/tests/mod.rs:open_test_db`

I should probably add a separate test for the db that actually opens and writes to disk

---

I think the proper way to implement the "current task" is to make the db expose a "select current" method. this doesn't actually break any invariants by itself - only not using it in other places does. 

so the problem is then where should we do so? in the top-level dispatched functions or inside the db functions themselves?

that is: should the DBBackend::add_task select a current task when there are none, or should that be up to the higher level function? from a separation of concerns viewpoint it shouldn't do anything other than add a task, but from a "state-consistency" point of view it kind of should. 

given that the db module is pub(crate) and not a real "public api" i think it's okay that you can put it in a somewhat inconsistent state. the rule "when you add a new task, if there are no current tasks, select one" is kind of more a "business rule" than a technical constraint

---

the above idea has the same problem that add has: we don't actually check that add is *really* working in the add tests, we just check that it doesn't error. the tests for list task and get current task are actually testing the implementations of add as well - if add or select current task (respectively) are broken, their tests don't fail, the tests for list/get_current fail. but we can't really test list without having a working add.

i'm not really sure what the right thing to do here is. maybe there's a better, more testable design.

one thing I considered is that both add and select_current task should return the task that was added/selected, but that doesn't actually check that they were stored - only reading them back checks that they were stored, which is again testing list.

---

I suppose the right thing to do in terms of TDD would be to mock the rest of the db but 1. you would still need to define the "get/list" api in each mock and 2. you would still need to write integration tests so why write the mocks
